{"ast":null,"code":"function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n\nexport var POSITIONS = ['top', 'right', 'bottom', 'left'];\nvar relatedDimension = {\n  top: 'height',\n  right: 'width',\n  bottom: 'height',\n  left: 'width'\n};\nvar dimensionPositionAttribute = {\n  height: 'top',\n  width: 'left'\n};\nvar positionComplements = {\n  top: 'bottom',\n  right: 'left',\n  bottom: 'top',\n  left: 'right'\n}; // always resolving to top/left is taken advantage of by knowing they are the\n// minimum edges of the bounding box\n\nvar positionSubstitutes = {\n  top: 'left',\n  right: 'top',\n  bottom: 'left',\n  left: 'top'\n};\n\nvar getBufferValues = function getBufferValues(buffer) {\n  if (Array.isArray(buffer)) {\n    var _buffer = _slicedToArray(buffer, 4),\n        topBuffer = _buffer[0],\n        rightBuffer = _buffer[1],\n        bottomBuffer = _buffer[2],\n        leftBuffer = _buffer[3];\n\n    return [topBuffer, rightBuffer, bottomBuffer, leftBuffer];\n  }\n\n  return [buffer, buffer, buffer, buffer];\n};\n/**\n * Calculates the absolute positioning (relative to document.body) to place a popover element\n *\n * @param anchor {HTMLElement} Element to anchor the popover to\n * @param popover {HTMLElement} Element containing the popover content\n * @param position {string} Position the user wants. One of [\"top\", \"right\", \"bottom\", \"left\"]\n * @param [forcePosition] {boolean} If true, use only the provided `position` value and don't try any other position\n * @param [align] {string} Cross-axis alignment. One of [\"top\", \"right\", \"bottom\", \"left\"]\n * @param [buffer=16] {number} Minimum distance between the popover and the bounding container\n * @param [offset=0] {number} Distance between the popover and the anchor\n * @param [allowCrossAxis=true] {boolean} Whether to allow the popover to be positioned on the cross-axis\n * @param [container] {HTMLElement} Element the popover must be constrained to fit within\n * @param [arrowConfig] {{arrowWidth: number, arrowBuffer: number}} If\n *  present, describes the size & constraints for an arrow element, and the\n *  function return value will include an `arrow` param with position details\n *\n * @returns {FindPopoverPositionResult} absolute page coordinates for the\n * popover, and the placement's relation to the anchor or undefined\n * there's no room.\n */\n\n\nexport function findPopoverPosition(_ref) {\n  var anchor = _ref.anchor,\n      popover = _ref.popover,\n      align = _ref.align,\n      position = _ref.position,\n      forcePosition = _ref.forcePosition,\n      _ref$buffer = _ref.buffer,\n      buffer = _ref$buffer === void 0 ? 16 : _ref$buffer,\n      _ref$offset = _ref.offset,\n      offset = _ref$offset === void 0 ? 0 : _ref$offset,\n      _ref$allowCrossAxis = _ref.allowCrossAxis,\n      allowCrossAxis = _ref$allowCrossAxis === void 0 ? true : _ref$allowCrossAxis,\n      container = _ref.container,\n      arrowConfig = _ref.arrowConfig,\n      returnBoundingBox = _ref.returnBoundingBox; // find the screen-relative bounding boxes of the anchor, popover, and container\n\n  var anchorBoundingBox = getElementBoundingBox(anchor);\n  var popoverBoundingBox = getElementBoundingBox(popover); // calculate the window's bounds\n  // window.(innerWidth|innerHeight) do not account for scrollbars\n  // so prefer the clientWidth/clientHeight of the DOM if available\n\n  var documentWidth = document.documentElement.clientWidth || window.innerWidth;\n  var documentHeight = document.documentElement.clientHeight || window.innerHeight;\n  var windowBoundingBox = {\n    top: 0,\n    right: documentWidth,\n    bottom: documentHeight,\n    left: 0,\n    height: documentHeight,\n    width: documentWidth\n  }; // if no container element is given fall back to using the window viewport\n\n  var containerBoundingBox = container ? getElementBoundingBox(container) : windowBoundingBox;\n  /**\n   * `position` was specified by the function caller and is a strong hint\n   * as to the preferred location of the popover relative to the anchor.\n   * However, we strongly prefer showing all of the popover content within\n   * the window+container boundary and will iterate over the four\n   * possible sides until a perfect fit is located. If none of the locations\n   * fully contain popover, the location with the best fit is selected.\n   *\n   * This approach first checks the preferred `position`, then its opposite\n   * along the same axis, next a location on the cross-axis, and finally it\n   * tests the remaining position.\n   *\n   * e.g.\n   * if position = \"top\" the order is top, bottom, left right\n   * if position = \"right\" the order is right, left, top, bottom\n   */\n  // Try the user-desired position first.\n\n  var iterationPositions = [position]; // keep user-defined alignment in the original positions.\n\n  var iterationAlignments = [align];\n\n  if (forcePosition !== true) {\n    iterationPositions.push(positionComplements[position]); // Try the complementary position.\n\n    iterationAlignments.push(align); // keep user-defined alignment in the complementary position.\n\n    if (allowCrossAxis) {\n      iterationPositions.push(positionSubstitutes[position], // Switch to the cross axis.\n      positionComplements[positionSubstitutes[position]] // Try the complementary position on the cross axis.\n      );\n      iterationAlignments.push(undefined, undefined); // discard desired alignment on cross-axis\n    }\n  } else {\n    // position is forced, if it conflicts with the alignment then reset align to `null`\n    // e.g. original placement request for `downLeft` is moved to the `left` side, future calls\n    // will position and align `left`, and `leftLeft` is not a valid placement\n    if (position === align || align !== undefined && position === positionComplements[align]) {\n      iterationAlignments[0] = undefined;\n    }\n  }\n\n  var bestFit = undefined;\n  var bestPosition = null;\n\n  for (var idx = 0; idx < iterationPositions.length; idx++) {\n    var iterationPosition = iterationPositions[idx]; // See if we can find a position with a better fit than we've found so far.\n\n    var screenCoordinates = getPopoverScreenCoordinates({\n      position: iterationPosition,\n      align: iterationAlignments[idx],\n      anchorBoundingBox: anchorBoundingBox,\n      popoverBoundingBox: popoverBoundingBox,\n      windowBoundingBox: windowBoundingBox,\n      containerBoundingBox: containerBoundingBox,\n      offset: offset,\n      buffer: buffer,\n      arrowConfig: arrowConfig\n    });\n\n    if (bestFit === undefined || screenCoordinates.fit > bestFit) {\n      bestFit = screenCoordinates.fit;\n      bestPosition = {\n        fit: screenCoordinates.fit,\n        position: iterationPosition,\n        top: screenCoordinates.top + window.pageYOffset,\n        left: screenCoordinates.left + window.pageXOffset,\n        arrow: screenCoordinates.arrow\n      }; // If we've already found the ideal fit, use that position.\n\n      if (bestFit === 1) {\n        break;\n      }\n    } // If we haven't improved the fit, then continue on and try a new position.\n\n  }\n\n  if (bestPosition == null) {\n    throw new Error('Failed to calculate bestPosition');\n  }\n\n  if (returnBoundingBox) {\n    bestPosition.anchorBoundingBox = anchorBoundingBox;\n  }\n\n  return bestPosition;\n}\n/**\n * Given a target position and the popover's surrounding context, returns either an\n * object with {top, left} screen coordinates or `null` if it's not possible to show\n * content in the target position\n * @param position {string} the target position, one of [\"top\", \"right\", \"bottom\", \"left\"]\n * @param align {string} target alignment on the cross-axis, one of [\"top\", \"right\", \"bottom\", \"left\"]\n * @param anchorBoundingBox {Object} bounding box of the anchor element\n * @param popoverBoundingBox {Object} bounding box of the popover element\n * @param windowBoundingBox {Object} bounding box of the window\n * @param containerBoundingBox {Object} bounding box of the container\n * @param [arrowConfig] {{arrowWidth: number, arrowBuffer: number}} If present, describes the size &\n *  constraints for an arrow element, and the function return value will include an `arrow` param\n *  with position details\n * @param [offset=0] {number} Distance between the popover and the anchor\n * @param [buffer=0] {number} Minimum distance between the popover's\n *  placement and the container edge\n *\n * @returns {GetPopoverScreenCoordinatesResult}\n *  object with top/left coordinates, the popover's relative position to the anchor, and how well the\n *  popover fits in the location (0.0 -> 1.0) coordinates and the popover's relative position, if\n *  there is no room in this placement then null\n */\n\nexport function getPopoverScreenCoordinates(_ref2) {\n  var _popoverPlacement, _ref3;\n\n  var position = _ref2.position,\n      align = _ref2.align,\n      anchorBoundingBox = _ref2.anchorBoundingBox,\n      popoverBoundingBox = _ref2.popoverBoundingBox,\n      windowBoundingBox = _ref2.windowBoundingBox,\n      containerBoundingBox = _ref2.containerBoundingBox,\n      arrowConfig = _ref2.arrowConfig,\n      _ref2$offset = _ref2.offset,\n      offset = _ref2$offset === void 0 ? 0 : _ref2$offset,\n      _ref2$buffer = _ref2.buffer,\n      buffer = _ref2$buffer === void 0 ? 0 : _ref2$buffer;\n  /**\n   * The goal is to find the best way to align the popover content\n   * on the given side of the anchor element. The popover prefers\n   * centering on the anchor but can shift along the cross-axis as needed.\n   *\n   * We return the top/left coordinates that best fit the popover inside\n   * the given boundaries, and also return the `fit` value which indicates\n   * what percentage of the popover is within the bounds.\n   *\n   * e.g. finding a location when position=top\n   * the preferred location is directly over the anchor\n   *\n   *        +----------------------+\n   *        |       popover        |\n   *        +----------------------+\n   *                   v\n   *            +--------------+\n   *            |    anchor    |\n   *            +--------------+\n   *\n   * but if anchor doesn't have much (or any) room on its ride side\n   * the popover will shift to the left\n   *\n   *    +----------------------+\n   *    |       popover        |\n   *    +----------------------+\n   *                   v\n   *            +--------------+\n   *            |    anchor    |\n   *            +--------------+\n   *\n   */\n\n  var crossAxisFirstSide = positionSubstitutes[position]; // \"top\" -> \"left\"\n\n  var crossAxisSecondSide = positionComplements[crossAxisFirstSide]; // \"left\" -> \"right\"\n\n  var crossAxisDimension = relatedDimension[crossAxisFirstSide]; // \"left\" -> \"width\"\n\n  var _getBufferValues = getBufferValues(buffer),\n      _getBufferValues2 = _slicedToArray(_getBufferValues, 4),\n      topBuffer = _getBufferValues2[0],\n      rightBuffer = _getBufferValues2[1],\n      bottomBuffer = _getBufferValues2[2],\n      leftBuffer = _getBufferValues2[3];\n\n  var _getCrossAxisPosition = getCrossAxisPosition({\n    crossAxisFirstSide: crossAxisFirstSide,\n    crossAxisSecondSide: crossAxisSecondSide,\n    crossAxisDimension: crossAxisDimension,\n    position: position,\n    align: align,\n    buffer: buffer,\n    offset: offset,\n    windowBoundingBox: windowBoundingBox,\n    containerBoundingBox: containerBoundingBox,\n    popoverBoundingBox: popoverBoundingBox,\n    anchorBoundingBox: anchorBoundingBox,\n    arrowConfig: arrowConfig\n  }),\n      crossAxisPosition = _getCrossAxisPosition.crossAxisPosition,\n      crossAxisArrowPosition = _getCrossAxisPosition.crossAxisArrowPosition;\n\n  var primaryAxisDimension = relatedDimension[position]; // \"top\" -> \"height\"\n\n  var primaryAxisPositionName = dimensionPositionAttribute[primaryAxisDimension]; // \"height\" -> \"top\"\n\n  var _getPrimaryAxisPositi = getPrimaryAxisPosition({\n    position: position,\n    offset: offset,\n    popoverBoundingBox: popoverBoundingBox,\n    anchorBoundingBox: anchorBoundingBox,\n    arrowConfig: arrowConfig\n  }),\n      primaryAxisPosition = _getPrimaryAxisPositi.primaryAxisPosition,\n      primaryAxisArrowPosition = _getPrimaryAxisPositi.primaryAxisArrowPosition;\n\n  var popoverPlacement = (_popoverPlacement = {}, _defineProperty(_popoverPlacement, crossAxisFirstSide, crossAxisPosition), _defineProperty(_popoverPlacement, primaryAxisPositionName, primaryAxisPosition), _popoverPlacement); // calculate the fit of the popover in this location\n  // fit is in range 0.0 -> 1.0 and is the percentage of the popover which is visible in this location\n\n  var combinedBoundingBox = intersectBoundingBoxes(windowBoundingBox, containerBoundingBox); // shrink the visible bounding box by `buffer`\n  // to compute a fit value\n\n  combinedBoundingBox.top += topBuffer;\n  combinedBoundingBox.right -= rightBuffer;\n  combinedBoundingBox.bottom -= bottomBuffer;\n  combinedBoundingBox.left += leftBuffer;\n  var fit = getVisibleFit({\n    top: popoverPlacement.top,\n    right: popoverPlacement.left + popoverBoundingBox.width,\n    bottom: popoverPlacement.top + popoverBoundingBox.height,\n    left: popoverPlacement.left,\n    width: popoverBoundingBox.width,\n    height: popoverBoundingBox.height\n  }, combinedBoundingBox);\n  var arrow = arrowConfig ? (_ref3 = {}, _defineProperty(_ref3, crossAxisFirstSide, crossAxisArrowPosition - popoverPlacement[crossAxisFirstSide]), _defineProperty(_ref3, primaryAxisPositionName, primaryAxisArrowPosition), _ref3) : undefined;\n  return {\n    fit: fit,\n    top: popoverPlacement.top,\n    left: popoverPlacement.left,\n    arrow: arrow ? {\n      left: arrow.left,\n      top: arrow.top\n    } : undefined\n  };\n}\n\nfunction getCrossAxisPosition(_ref4) {\n  var crossAxisFirstSide = _ref4.crossAxisFirstSide,\n      crossAxisSecondSide = _ref4.crossAxisSecondSide,\n      crossAxisDimension = _ref4.crossAxisDimension,\n      position = _ref4.position,\n      align = _ref4.align,\n      buffer = _ref4.buffer,\n      offset = _ref4.offset,\n      windowBoundingBox = _ref4.windowBoundingBox,\n      containerBoundingBox = _ref4.containerBoundingBox,\n      popoverBoundingBox = _ref4.popoverBoundingBox,\n      anchorBoundingBox = _ref4.anchorBoundingBox,\n      arrowConfig = _ref4.arrowConfig; // how much of the popover overflows past either side of the anchor if its centered\n\n  var popoverSizeOnCrossAxis = popoverBoundingBox[crossAxisDimension];\n  var anchorSizeOnCrossAxis = anchorBoundingBox[crossAxisDimension];\n  var anchorHalfSize = anchorSizeOnCrossAxis / 2; // the popover's original position on the cross-axis is determined by:\n\n  var crossAxisPositionOriginal = anchorBoundingBox[crossAxisFirstSide] + // where the anchor is located\n  anchorHalfSize - // plus half anchor dimension\n  popoverSizeOnCrossAxis / 2; // less half the popover dimension\n  // To fit the content within both the window and container,\n  // compute the smaller of the two spaces along each edge\n\n  var combinedBoundingBox = intersectBoundingBoxes(windowBoundingBox, containerBoundingBox);\n  var availableSpace = getAvailableSpace(anchorBoundingBox, combinedBoundingBox, buffer, offset, position);\n  var minimumSpace = arrowConfig ? arrowConfig.arrowBuffer : 0;\n  var contentOverflowSize = (popoverSizeOnCrossAxis - anchorSizeOnCrossAxis) / 2;\n  var alignAmount = 0;\n  var alignDirection = 1;\n  var amountOfShiftNeeded = 0;\n  var shiftDirection = 1;\n\n  if (align != null) {\n    // no alignment, find how much the container boundary requires the content to shift\n    alignDirection = align === 'top' || align === 'left' ? 1 : -1;\n    alignAmount = contentOverflowSize;\n    var alignedOverflowAmount = contentOverflowSize + alignAmount;\n    var needsShift = alignedOverflowAmount > availableSpace[positionComplements[align]];\n    amountOfShiftNeeded = needsShift ? alignedOverflowAmount - availableSpace[positionComplements[align]] : 0;\n    shiftDirection = -1 * alignDirection;\n  } else {\n    // shifting the popover to one side may yield a better fit\n    var spaceAvailableOnFirstSide = availableSpace[crossAxisFirstSide];\n    var spaceAvailableOnSecondSide = availableSpace[crossAxisSecondSide];\n    var isShiftTowardFirstSide = spaceAvailableOnFirstSide > spaceAvailableOnSecondSide;\n    shiftDirection = isShiftTowardFirstSide ? -1 : 1; // determine which direction has more room and the popover should shift to\n\n    var leastAvailableSpace = Math.min(spaceAvailableOnFirstSide, spaceAvailableOnSecondSide);\n\n    var _needsShift = contentOverflowSize > leastAvailableSpace;\n\n    amountOfShiftNeeded = _needsShift ? contentOverflowSize - leastAvailableSpace : 0;\n  } // shift over the popover if necessary\n\n\n  var shiftAmount = amountOfShiftNeeded * shiftDirection;\n  var crossAxisPosition = crossAxisPositionOriginal + shiftAmount + alignAmount * alignDirection; // if an `arrowConfig` is specified, find where to position the arrow\n\n  var crossAxisArrowPosition;\n\n  if (arrowConfig) {\n    var arrowWidth = arrowConfig.arrowWidth;\n    crossAxisArrowPosition = anchorBoundingBox[crossAxisFirstSide] + anchorHalfSize - arrowWidth / 2; // make sure there's enough buffer around the arrow\n    // by calculating how how much the arrow would need to move\n    // but instead of moving the arrow, shift the popover content\n\n    if (crossAxisArrowPosition < crossAxisPosition + minimumSpace) {\n      // arrow is too close to the minimum side\n      var difference = crossAxisPosition + minimumSpace - crossAxisArrowPosition;\n      crossAxisPosition -= difference;\n    } else if (crossAxisArrowPosition + minimumSpace + arrowWidth > crossAxisPosition + popoverSizeOnCrossAxis) {\n      // arrow is too close to the maximum side\n      var edge = crossAxisPosition + popoverSizeOnCrossAxis;\n\n      var _difference = crossAxisArrowPosition - (edge - minimumSpace - arrowWidth);\n\n      crossAxisPosition += _difference;\n    }\n  }\n\n  return {\n    crossAxisPosition: crossAxisPosition,\n    crossAxisArrowPosition: crossAxisArrowPosition\n  };\n}\n\nfunction getPrimaryAxisPosition(_ref5) {\n  var position = _ref5.position,\n      offset = _ref5.offset,\n      popoverBoundingBox = _ref5.popoverBoundingBox,\n      anchorBoundingBox = _ref5.anchorBoundingBox,\n      arrowConfig = _ref5.arrowConfig; // if positioning to the top or left, the target position decreases\n  // from the anchor's top or left, otherwise the position adds to the anchor's\n\n  var isOffsetDecreasing = position === 'top' || position === 'left';\n  var primaryAxisDimension = relatedDimension[position]; // \"top\" -> \"height\"\n\n  var popoverSizeOnPrimaryAxis = popoverBoundingBox[primaryAxisDimension]; // start at the top or left edge of the anchor element\n\n  var primaryAxisPositionName = dimensionPositionAttribute[primaryAxisDimension]; // \"height\" -> \"top\"\n\n  var anchorEdgeOrigin = anchorBoundingBox[primaryAxisPositionName]; // find the popover position on the primary axis\n\n  var anchorSizeOnPrimaryAxis = anchorBoundingBox[primaryAxisDimension];\n  var primaryAxisOffset = isOffsetDecreasing ? popoverSizeOnPrimaryAxis : anchorSizeOnPrimaryAxis;\n  var contentOffset = (offset + primaryAxisOffset) * (isOffsetDecreasing ? -1 : 1);\n  var primaryAxisPosition = anchorEdgeOrigin + contentOffset;\n  var primaryAxisArrowPosition;\n\n  if (arrowConfig) {\n    primaryAxisArrowPosition = isOffsetDecreasing ? popoverSizeOnPrimaryAxis : 0;\n  }\n\n  return {\n    primaryAxisPosition: primaryAxisPosition,\n    primaryAxisArrowPosition: primaryAxisArrowPosition\n  };\n}\n/**\n * Finds the client pixel coordinate of each edge for the element's bounding box,\n * and the bounding box's width & height\n *\n * @param {HTMLElement} element\n * @returns {{top: number, right: number, bottom: number, left: number, height: number, width: number}}\n */\n\n\nexport function getElementBoundingBox(element) {\n  var rect = element.getBoundingClientRect();\n  return {\n    top: rect.top,\n    right: rect.right,\n    bottom: rect.bottom,\n    left: rect.left,\n    height: rect.height,\n    width: rect.width\n  };\n}\n/**\n * Calculates the available content space between anchor and container\n *\n * @param {Object} anchorBoundingBox Client bounding box of the anchor element\n * @param {Object} containerBoundingBox Client bounding box of the container element\n * @param {number} buffer Minimum distance between the popover and the bounding container\n * @param {number} offset Distance between the popover and the anchor\n * @param {string} offsetSide Side the offset needs to be applied to, one\n *  of [\"top\", \"right\", \"bottom\", \"left\"]\n * @returns {{top: number, right: number, bottom: number, left: number}}\n */\n\nexport function getAvailableSpace(anchorBoundingBox, containerBoundingBox, buffer, offset, offsetSide) {\n  var _getBufferValues3 = getBufferValues(buffer),\n      _getBufferValues4 = _slicedToArray(_getBufferValues3, 4),\n      topBuffer = _getBufferValues4[0],\n      rightBuffer = _getBufferValues4[1],\n      bottomBuffer = _getBufferValues4[2],\n      leftBuffer = _getBufferValues4[3];\n\n  return {\n    top: anchorBoundingBox.top - containerBoundingBox.top - topBuffer - (offsetSide === 'top' ? offset : 0),\n    right: containerBoundingBox.right - anchorBoundingBox.right - rightBuffer - (offsetSide === 'right' ? offset : 0),\n    bottom: containerBoundingBox.bottom - anchorBoundingBox.bottom - bottomBuffer - (offsetSide === 'bottom' ? offset : 0),\n    left: anchorBoundingBox.left - containerBoundingBox.left - leftBuffer - (offsetSide === 'left' ? offset : 0)\n  };\n}\n/**\n * Computes the fit (overlap) of the content within the container, fit is in range 0.0 => 1.0\n * @param contentBoundingBox bounding box of content to calculate fit for\n * @param containerBoundingBox bounding box of container\n * @returns {number}\n */\n\nexport function getVisibleFit(contentBoundingBox, containerBoundingBox) {\n  var intersection = intersectBoundingBoxes(contentBoundingBox, containerBoundingBox);\n\n  if (intersection.left > intersection.right || intersection.top > intersection.top) {\n    // there is no intersection, the boxes are completely separated on at least one axis\n    return 0;\n  }\n\n  var intersectionArea = (intersection.right - intersection.left) * (intersection.bottom - intersection.top);\n  var contentArea = (contentBoundingBox.right - contentBoundingBox.left) * (contentBoundingBox.bottom - contentBoundingBox.top);\n  return intersectionArea / contentArea;\n}\n/**\n * Calculates the intersection space between two bounding boxes\n *\n * @param firstBox\n * @param secondBox\n * @returns {EuiClientRect}\n */\n\nexport function intersectBoundingBoxes(firstBox, secondBox) {\n  var top = Math.max(firstBox.top, secondBox.top);\n  var right = Math.min(firstBox.right, secondBox.right);\n  var bottom = Math.min(firstBox.bottom, secondBox.bottom);\n  var left = Math.max(firstBox.left, secondBox.left);\n  var height = Math.max(bottom - top, 0);\n  var width = Math.max(right - left, 0);\n  return {\n    top: top,\n    right: right,\n    bottom: bottom,\n    left: left,\n    height: height,\n    width: width\n  };\n}\n/**\n * Returns the top-most defined z-index in the element's ancestor hierarchy\n * relative to the `target` element; if no z-index is defined, returns 0\n * @param element {HTMLElement}\n * @param cousin {HTMLElement}\n * @returns {number}\n */\n\nexport function getElementZIndex(element, cousin) {\n  /**\n   * finding the z-index of `element` is not the full story\n   * its the CSS stacking context that is important\n   * take this DOM for example:\n   * body\n   *   section[z-index: 1000]\n   *     p[z-index: 500]\n   *       button\n   *   div\n   *\n   * what z-index does the `div` need to display next to `button`?\n   * the `div` and `section` are where the stacking context splits\n   * so `div` needs to copy `section`'s z-index in order to\n   * appear next to / over `button`\n   *\n   * calculate this by starting at `button` and finding its offsetParents\n   * then walk the parents from top -> down until the stacking context\n   * split is found, or if there is no split then a specific z-index is unimportant\n   */\n  // build the array of the element + its offset parents\n  var nodesToInspect = [];\n\n  while (true) {\n    nodesToInspect.push(element); // AFAICT this is a valid cast - the libdefs appear wrong\n\n    element = element.offsetParent; // stop if there is no parent\n\n    if (element == null) {\n      break;\n    } // stop if the parent contains the related element\n    // as this is the z-index ancestor\n\n\n    if (element.contains(cousin)) {\n      break;\n    }\n  } // reverse the nodes to walk from top -> element\n\n\n  nodesToInspect.reverse();\n\n  for (var _i2 = 0, _nodesToInspect = nodesToInspect; _i2 < _nodesToInspect.length; _i2++) {\n    var node = _nodesToInspect[_i2]; // get this node's z-index css value\n\n    var zIndex = window.document.defaultView.getComputedStyle(node).getPropertyValue('z-index'); // if the z-index is not a number (e.g. \"auto\") return null, else the value\n\n    var parsedZIndex = parseInt(zIndex, 10);\n\n    if (!isNaN(parsedZIndex)) {\n      return parsedZIndex;\n    }\n  }\n\n  return 0;\n}","map":{"version":3,"sources":["/Users/inwoo/Projects/coldcallproject/coldcallproject/node_modules/@elastic/eui/es/services/popover/popover_positioning.js"],"names":["_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","_slicedToArray","arr","i","_arrayWithHoles","_iterableToArrayLimit","_unsupportedIterableToArray","_nonIterableRest","TypeError","o","minLen","_arrayLikeToArray","n","prototype","toString","call","slice","constructor","name","Array","from","test","len","length","arr2","Symbol","iterator","_arr","_n","_d","_e","undefined","_i","_s","next","done","push","err","isArray","POSITIONS","relatedDimension","top","right","bottom","left","dimensionPositionAttribute","height","width","positionComplements","positionSubstitutes","getBufferValues","buffer","_buffer","topBuffer","rightBuffer","bottomBuffer","leftBuffer","findPopoverPosition","_ref","anchor","popover","align","position","forcePosition","_ref$buffer","_ref$offset","offset","_ref$allowCrossAxis","allowCrossAxis","container","arrowConfig","returnBoundingBox","anchorBoundingBox","getElementBoundingBox","popoverBoundingBox","documentWidth","document","documentElement","clientWidth","window","innerWidth","documentHeight","clientHeight","innerHeight","windowBoundingBox","containerBoundingBox","iterationPositions","iterationAlignments","bestFit","bestPosition","idx","iterationPosition","screenCoordinates","getPopoverScreenCoordinates","fit","pageYOffset","pageXOffset","arrow","Error","_ref2","_popoverPlacement","_ref3","_ref2$offset","_ref2$buffer","crossAxisFirstSide","crossAxisSecondSide","crossAxisDimension","_getBufferValues","_getBufferValues2","_getCrossAxisPosition","getCrossAxisPosition","crossAxisPosition","crossAxisArrowPosition","primaryAxisDimension","primaryAxisPositionName","_getPrimaryAxisPositi","getPrimaryAxisPosition","primaryAxisPosition","primaryAxisArrowPosition","popoverPlacement","combinedBoundingBox","intersectBoundingBoxes","getVisibleFit","_ref4","popoverSizeOnCrossAxis","anchorSizeOnCrossAxis","anchorHalfSize","crossAxisPositionOriginal","availableSpace","getAvailableSpace","minimumSpace","arrowBuffer","contentOverflowSize","alignAmount","alignDirection","amountOfShiftNeeded","shiftDirection","alignedOverflowAmount","needsShift","spaceAvailableOnFirstSide","spaceAvailableOnSecondSide","isShiftTowardFirstSide","leastAvailableSpace","Math","min","_needsShift","shiftAmount","arrowWidth","difference","edge","_difference","_ref5","isOffsetDecreasing","popoverSizeOnPrimaryAxis","anchorEdgeOrigin","anchorSizeOnPrimaryAxis","primaryAxisOffset","contentOffset","element","rect","getBoundingClientRect","offsetSide","_getBufferValues3","_getBufferValues4","contentBoundingBox","intersection","intersectionArea","contentArea","firstBox","secondBox","max","getElementZIndex","cousin","nodesToInspect","offsetParent","contains","reverse","_i2","_nodesToInspect","node","zIndex","defaultView","getComputedStyle","getPropertyValue","parsedZIndex","parseInt","isNaN"],"mappings":"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","sourcesContent":["function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nexport var POSITIONS = ['top', 'right', 'bottom', 'left'];\nvar relatedDimension = {\n  top: 'height',\n  right: 'width',\n  bottom: 'height',\n  left: 'width'\n};\nvar dimensionPositionAttribute = {\n  height: 'top',\n  width: 'left'\n};\nvar positionComplements = {\n  top: 'bottom',\n  right: 'left',\n  bottom: 'top',\n  left: 'right'\n}; // always resolving to top/left is taken advantage of by knowing they are the\n// minimum edges of the bounding box\n\nvar positionSubstitutes = {\n  top: 'left',\n  right: 'top',\n  bottom: 'left',\n  left: 'top'\n};\n\nvar getBufferValues = function getBufferValues(buffer) {\n  if (Array.isArray(buffer)) {\n    var _buffer = _slicedToArray(buffer, 4),\n        topBuffer = _buffer[0],\n        rightBuffer = _buffer[1],\n        bottomBuffer = _buffer[2],\n        leftBuffer = _buffer[3];\n\n    return [topBuffer, rightBuffer, bottomBuffer, leftBuffer];\n  }\n\n  return [buffer, buffer, buffer, buffer];\n};\n/**\n * Calculates the absolute positioning (relative to document.body) to place a popover element\n *\n * @param anchor {HTMLElement} Element to anchor the popover to\n * @param popover {HTMLElement} Element containing the popover content\n * @param position {string} Position the user wants. One of [\"top\", \"right\", \"bottom\", \"left\"]\n * @param [forcePosition] {boolean} If true, use only the provided `position` value and don't try any other position\n * @param [align] {string} Cross-axis alignment. One of [\"top\", \"right\", \"bottom\", \"left\"]\n * @param [buffer=16] {number} Minimum distance between the popover and the bounding container\n * @param [offset=0] {number} Distance between the popover and the anchor\n * @param [allowCrossAxis=true] {boolean} Whether to allow the popover to be positioned on the cross-axis\n * @param [container] {HTMLElement} Element the popover must be constrained to fit within\n * @param [arrowConfig] {{arrowWidth: number, arrowBuffer: number}} If\n *  present, describes the size & constraints for an arrow element, and the\n *  function return value will include an `arrow` param with position details\n *\n * @returns {FindPopoverPositionResult} absolute page coordinates for the\n * popover, and the placement's relation to the anchor or undefined\n * there's no room.\n */\n\n\nexport function findPopoverPosition(_ref) {\n  var anchor = _ref.anchor,\n      popover = _ref.popover,\n      align = _ref.align,\n      position = _ref.position,\n      forcePosition = _ref.forcePosition,\n      _ref$buffer = _ref.buffer,\n      buffer = _ref$buffer === void 0 ? 16 : _ref$buffer,\n      _ref$offset = _ref.offset,\n      offset = _ref$offset === void 0 ? 0 : _ref$offset,\n      _ref$allowCrossAxis = _ref.allowCrossAxis,\n      allowCrossAxis = _ref$allowCrossAxis === void 0 ? true : _ref$allowCrossAxis,\n      container = _ref.container,\n      arrowConfig = _ref.arrowConfig,\n      returnBoundingBox = _ref.returnBoundingBox;\n  // find the screen-relative bounding boxes of the anchor, popover, and container\n  var anchorBoundingBox = getElementBoundingBox(anchor);\n  var popoverBoundingBox = getElementBoundingBox(popover); // calculate the window's bounds\n  // window.(innerWidth|innerHeight) do not account for scrollbars\n  // so prefer the clientWidth/clientHeight of the DOM if available\n\n  var documentWidth = document.documentElement.clientWidth || window.innerWidth;\n  var documentHeight = document.documentElement.clientHeight || window.innerHeight;\n  var windowBoundingBox = {\n    top: 0,\n    right: documentWidth,\n    bottom: documentHeight,\n    left: 0,\n    height: documentHeight,\n    width: documentWidth\n  }; // if no container element is given fall back to using the window viewport\n\n  var containerBoundingBox = container ? getElementBoundingBox(container) : windowBoundingBox;\n  /**\n   * `position` was specified by the function caller and is a strong hint\n   * as to the preferred location of the popover relative to the anchor.\n   * However, we strongly prefer showing all of the popover content within\n   * the window+container boundary and will iterate over the four\n   * possible sides until a perfect fit is located. If none of the locations\n   * fully contain popover, the location with the best fit is selected.\n   *\n   * This approach first checks the preferred `position`, then its opposite\n   * along the same axis, next a location on the cross-axis, and finally it\n   * tests the remaining position.\n   *\n   * e.g.\n   * if position = \"top\" the order is top, bottom, left right\n   * if position = \"right\" the order is right, left, top, bottom\n   */\n  // Try the user-desired position first.\n\n  var iterationPositions = [position]; // keep user-defined alignment in the original positions.\n\n  var iterationAlignments = [align];\n\n  if (forcePosition !== true) {\n    iterationPositions.push(positionComplements[position]); // Try the complementary position.\n\n    iterationAlignments.push(align); // keep user-defined alignment in the complementary position.\n\n    if (allowCrossAxis) {\n      iterationPositions.push(positionSubstitutes[position], // Switch to the cross axis.\n      positionComplements[positionSubstitutes[position]] // Try the complementary position on the cross axis.\n      );\n      iterationAlignments.push(undefined, undefined); // discard desired alignment on cross-axis\n    }\n  } else {\n    // position is forced, if it conflicts with the alignment then reset align to `null`\n    // e.g. original placement request for `downLeft` is moved to the `left` side, future calls\n    // will position and align `left`, and `leftLeft` is not a valid placement\n    if (position === align || align !== undefined && position === positionComplements[align]) {\n      iterationAlignments[0] = undefined;\n    }\n  }\n\n  var bestFit = undefined;\n  var bestPosition = null;\n\n  for (var idx = 0; idx < iterationPositions.length; idx++) {\n    var iterationPosition = iterationPositions[idx]; // See if we can find a position with a better fit than we've found so far.\n\n    var screenCoordinates = getPopoverScreenCoordinates({\n      position: iterationPosition,\n      align: iterationAlignments[idx],\n      anchorBoundingBox: anchorBoundingBox,\n      popoverBoundingBox: popoverBoundingBox,\n      windowBoundingBox: windowBoundingBox,\n      containerBoundingBox: containerBoundingBox,\n      offset: offset,\n      buffer: buffer,\n      arrowConfig: arrowConfig\n    });\n\n    if (bestFit === undefined || screenCoordinates.fit > bestFit) {\n      bestFit = screenCoordinates.fit;\n      bestPosition = {\n        fit: screenCoordinates.fit,\n        position: iterationPosition,\n        top: screenCoordinates.top + window.pageYOffset,\n        left: screenCoordinates.left + window.pageXOffset,\n        arrow: screenCoordinates.arrow\n      }; // If we've already found the ideal fit, use that position.\n\n      if (bestFit === 1) {\n        break;\n      }\n    } // If we haven't improved the fit, then continue on and try a new position.\n\n  }\n\n  if (bestPosition == null) {\n    throw new Error('Failed to calculate bestPosition');\n  }\n\n  if (returnBoundingBox) {\n    bestPosition.anchorBoundingBox = anchorBoundingBox;\n  }\n\n  return bestPosition;\n}\n\n/**\n * Given a target position and the popover's surrounding context, returns either an\n * object with {top, left} screen coordinates or `null` if it's not possible to show\n * content in the target position\n * @param position {string} the target position, one of [\"top\", \"right\", \"bottom\", \"left\"]\n * @param align {string} target alignment on the cross-axis, one of [\"top\", \"right\", \"bottom\", \"left\"]\n * @param anchorBoundingBox {Object} bounding box of the anchor element\n * @param popoverBoundingBox {Object} bounding box of the popover element\n * @param windowBoundingBox {Object} bounding box of the window\n * @param containerBoundingBox {Object} bounding box of the container\n * @param [arrowConfig] {{arrowWidth: number, arrowBuffer: number}} If present, describes the size &\n *  constraints for an arrow element, and the function return value will include an `arrow` param\n *  with position details\n * @param [offset=0] {number} Distance between the popover and the anchor\n * @param [buffer=0] {number} Minimum distance between the popover's\n *  placement and the container edge\n *\n * @returns {GetPopoverScreenCoordinatesResult}\n *  object with top/left coordinates, the popover's relative position to the anchor, and how well the\n *  popover fits in the location (0.0 -> 1.0) coordinates and the popover's relative position, if\n *  there is no room in this placement then null\n */\nexport function getPopoverScreenCoordinates(_ref2) {\n  var _popoverPlacement, _ref3;\n\n  var position = _ref2.position,\n      align = _ref2.align,\n      anchorBoundingBox = _ref2.anchorBoundingBox,\n      popoverBoundingBox = _ref2.popoverBoundingBox,\n      windowBoundingBox = _ref2.windowBoundingBox,\n      containerBoundingBox = _ref2.containerBoundingBox,\n      arrowConfig = _ref2.arrowConfig,\n      _ref2$offset = _ref2.offset,\n      offset = _ref2$offset === void 0 ? 0 : _ref2$offset,\n      _ref2$buffer = _ref2.buffer,\n      buffer = _ref2$buffer === void 0 ? 0 : _ref2$buffer;\n\n  /**\n   * The goal is to find the best way to align the popover content\n   * on the given side of the anchor element. The popover prefers\n   * centering on the anchor but can shift along the cross-axis as needed.\n   *\n   * We return the top/left coordinates that best fit the popover inside\n   * the given boundaries, and also return the `fit` value which indicates\n   * what percentage of the popover is within the bounds.\n   *\n   * e.g. finding a location when position=top\n   * the preferred location is directly over the anchor\n   *\n   *        +----------------------+\n   *        |       popover        |\n   *        +----------------------+\n   *                   v\n   *            +--------------+\n   *            |    anchor    |\n   *            +--------------+\n   *\n   * but if anchor doesn't have much (or any) room on its ride side\n   * the popover will shift to the left\n   *\n   *    +----------------------+\n   *    |       popover        |\n   *    +----------------------+\n   *                   v\n   *            +--------------+\n   *            |    anchor    |\n   *            +--------------+\n   *\n   */\n  var crossAxisFirstSide = positionSubstitutes[position]; // \"top\" -> \"left\"\n\n  var crossAxisSecondSide = positionComplements[crossAxisFirstSide]; // \"left\" -> \"right\"\n\n  var crossAxisDimension = relatedDimension[crossAxisFirstSide]; // \"left\" -> \"width\"\n\n  var _getBufferValues = getBufferValues(buffer),\n      _getBufferValues2 = _slicedToArray(_getBufferValues, 4),\n      topBuffer = _getBufferValues2[0],\n      rightBuffer = _getBufferValues2[1],\n      bottomBuffer = _getBufferValues2[2],\n      leftBuffer = _getBufferValues2[3];\n\n  var _getCrossAxisPosition = getCrossAxisPosition({\n    crossAxisFirstSide: crossAxisFirstSide,\n    crossAxisSecondSide: crossAxisSecondSide,\n    crossAxisDimension: crossAxisDimension,\n    position: position,\n    align: align,\n    buffer: buffer,\n    offset: offset,\n    windowBoundingBox: windowBoundingBox,\n    containerBoundingBox: containerBoundingBox,\n    popoverBoundingBox: popoverBoundingBox,\n    anchorBoundingBox: anchorBoundingBox,\n    arrowConfig: arrowConfig\n  }),\n      crossAxisPosition = _getCrossAxisPosition.crossAxisPosition,\n      crossAxisArrowPosition = _getCrossAxisPosition.crossAxisArrowPosition;\n\n  var primaryAxisDimension = relatedDimension[position]; // \"top\" -> \"height\"\n\n  var primaryAxisPositionName = dimensionPositionAttribute[primaryAxisDimension]; // \"height\" -> \"top\"\n\n  var _getPrimaryAxisPositi = getPrimaryAxisPosition({\n    position: position,\n    offset: offset,\n    popoverBoundingBox: popoverBoundingBox,\n    anchorBoundingBox: anchorBoundingBox,\n    arrowConfig: arrowConfig\n  }),\n      primaryAxisPosition = _getPrimaryAxisPositi.primaryAxisPosition,\n      primaryAxisArrowPosition = _getPrimaryAxisPositi.primaryAxisArrowPosition;\n\n  var popoverPlacement = (_popoverPlacement = {}, _defineProperty(_popoverPlacement, crossAxisFirstSide, crossAxisPosition), _defineProperty(_popoverPlacement, primaryAxisPositionName, primaryAxisPosition), _popoverPlacement); // calculate the fit of the popover in this location\n  // fit is in range 0.0 -> 1.0 and is the percentage of the popover which is visible in this location\n\n  var combinedBoundingBox = intersectBoundingBoxes(windowBoundingBox, containerBoundingBox); // shrink the visible bounding box by `buffer`\n  // to compute a fit value\n\n  combinedBoundingBox.top += topBuffer;\n  combinedBoundingBox.right -= rightBuffer;\n  combinedBoundingBox.bottom -= bottomBuffer;\n  combinedBoundingBox.left += leftBuffer;\n  var fit = getVisibleFit({\n    top: popoverPlacement.top,\n    right: popoverPlacement.left + popoverBoundingBox.width,\n    bottom: popoverPlacement.top + popoverBoundingBox.height,\n    left: popoverPlacement.left,\n    width: popoverBoundingBox.width,\n    height: popoverBoundingBox.height\n  }, combinedBoundingBox);\n  var arrow = arrowConfig ? (_ref3 = {}, _defineProperty(_ref3, crossAxisFirstSide, crossAxisArrowPosition - popoverPlacement[crossAxisFirstSide]), _defineProperty(_ref3, primaryAxisPositionName, primaryAxisArrowPosition), _ref3) : undefined;\n  return {\n    fit: fit,\n    top: popoverPlacement.top,\n    left: popoverPlacement.left,\n    arrow: arrow ? {\n      left: arrow.left,\n      top: arrow.top\n    } : undefined\n  };\n}\n\nfunction getCrossAxisPosition(_ref4) {\n  var crossAxisFirstSide = _ref4.crossAxisFirstSide,\n      crossAxisSecondSide = _ref4.crossAxisSecondSide,\n      crossAxisDimension = _ref4.crossAxisDimension,\n      position = _ref4.position,\n      align = _ref4.align,\n      buffer = _ref4.buffer,\n      offset = _ref4.offset,\n      windowBoundingBox = _ref4.windowBoundingBox,\n      containerBoundingBox = _ref4.containerBoundingBox,\n      popoverBoundingBox = _ref4.popoverBoundingBox,\n      anchorBoundingBox = _ref4.anchorBoundingBox,\n      arrowConfig = _ref4.arrowConfig;\n  // how much of the popover overflows past either side of the anchor if its centered\n  var popoverSizeOnCrossAxis = popoverBoundingBox[crossAxisDimension];\n  var anchorSizeOnCrossAxis = anchorBoundingBox[crossAxisDimension];\n  var anchorHalfSize = anchorSizeOnCrossAxis / 2; // the popover's original position on the cross-axis is determined by:\n\n  var crossAxisPositionOriginal = anchorBoundingBox[crossAxisFirstSide] + // where the anchor is located\n  anchorHalfSize - // plus half anchor dimension\n  popoverSizeOnCrossAxis / 2; // less half the popover dimension\n  // To fit the content within both the window and container,\n  // compute the smaller of the two spaces along each edge\n\n  var combinedBoundingBox = intersectBoundingBoxes(windowBoundingBox, containerBoundingBox);\n  var availableSpace = getAvailableSpace(anchorBoundingBox, combinedBoundingBox, buffer, offset, position);\n  var minimumSpace = arrowConfig ? arrowConfig.arrowBuffer : 0;\n  var contentOverflowSize = (popoverSizeOnCrossAxis - anchorSizeOnCrossAxis) / 2;\n  var alignAmount = 0;\n  var alignDirection = 1;\n  var amountOfShiftNeeded = 0;\n  var shiftDirection = 1;\n\n  if (align != null) {\n    // no alignment, find how much the container boundary requires the content to shift\n    alignDirection = align === 'top' || align === 'left' ? 1 : -1;\n    alignAmount = contentOverflowSize;\n    var alignedOverflowAmount = contentOverflowSize + alignAmount;\n    var needsShift = alignedOverflowAmount > availableSpace[positionComplements[align]];\n    amountOfShiftNeeded = needsShift ? alignedOverflowAmount - availableSpace[positionComplements[align]] : 0;\n    shiftDirection = -1 * alignDirection;\n  } else {\n    // shifting the popover to one side may yield a better fit\n    var spaceAvailableOnFirstSide = availableSpace[crossAxisFirstSide];\n    var spaceAvailableOnSecondSide = availableSpace[crossAxisSecondSide];\n    var isShiftTowardFirstSide = spaceAvailableOnFirstSide > spaceAvailableOnSecondSide;\n    shiftDirection = isShiftTowardFirstSide ? -1 : 1; // determine which direction has more room and the popover should shift to\n\n    var leastAvailableSpace = Math.min(spaceAvailableOnFirstSide, spaceAvailableOnSecondSide);\n\n    var _needsShift = contentOverflowSize > leastAvailableSpace;\n\n    amountOfShiftNeeded = _needsShift ? contentOverflowSize - leastAvailableSpace : 0;\n  } // shift over the popover if necessary\n\n\n  var shiftAmount = amountOfShiftNeeded * shiftDirection;\n  var crossAxisPosition = crossAxisPositionOriginal + shiftAmount + alignAmount * alignDirection; // if an `arrowConfig` is specified, find where to position the arrow\n\n  var crossAxisArrowPosition;\n\n  if (arrowConfig) {\n    var arrowWidth = arrowConfig.arrowWidth;\n    crossAxisArrowPosition = anchorBoundingBox[crossAxisFirstSide] + anchorHalfSize - arrowWidth / 2; // make sure there's enough buffer around the arrow\n    // by calculating how how much the arrow would need to move\n    // but instead of moving the arrow, shift the popover content\n\n    if (crossAxisArrowPosition < crossAxisPosition + minimumSpace) {\n      // arrow is too close to the minimum side\n      var difference = crossAxisPosition + minimumSpace - crossAxisArrowPosition;\n      crossAxisPosition -= difference;\n    } else if (crossAxisArrowPosition + minimumSpace + arrowWidth > crossAxisPosition + popoverSizeOnCrossAxis) {\n      // arrow is too close to the maximum side\n      var edge = crossAxisPosition + popoverSizeOnCrossAxis;\n\n      var _difference = crossAxisArrowPosition - (edge - minimumSpace - arrowWidth);\n\n      crossAxisPosition += _difference;\n    }\n  }\n\n  return {\n    crossAxisPosition: crossAxisPosition,\n    crossAxisArrowPosition: crossAxisArrowPosition\n  };\n}\n\nfunction getPrimaryAxisPosition(_ref5) {\n  var position = _ref5.position,\n      offset = _ref5.offset,\n      popoverBoundingBox = _ref5.popoverBoundingBox,\n      anchorBoundingBox = _ref5.anchorBoundingBox,\n      arrowConfig = _ref5.arrowConfig;\n  // if positioning to the top or left, the target position decreases\n  // from the anchor's top or left, otherwise the position adds to the anchor's\n  var isOffsetDecreasing = position === 'top' || position === 'left';\n  var primaryAxisDimension = relatedDimension[position]; // \"top\" -> \"height\"\n\n  var popoverSizeOnPrimaryAxis = popoverBoundingBox[primaryAxisDimension]; // start at the top or left edge of the anchor element\n\n  var primaryAxisPositionName = dimensionPositionAttribute[primaryAxisDimension]; // \"height\" -> \"top\"\n\n  var anchorEdgeOrigin = anchorBoundingBox[primaryAxisPositionName]; // find the popover position on the primary axis\n\n  var anchorSizeOnPrimaryAxis = anchorBoundingBox[primaryAxisDimension];\n  var primaryAxisOffset = isOffsetDecreasing ? popoverSizeOnPrimaryAxis : anchorSizeOnPrimaryAxis;\n  var contentOffset = (offset + primaryAxisOffset) * (isOffsetDecreasing ? -1 : 1);\n  var primaryAxisPosition = anchorEdgeOrigin + contentOffset;\n  var primaryAxisArrowPosition;\n\n  if (arrowConfig) {\n    primaryAxisArrowPosition = isOffsetDecreasing ? popoverSizeOnPrimaryAxis : 0;\n  }\n\n  return {\n    primaryAxisPosition: primaryAxisPosition,\n    primaryAxisArrowPosition: primaryAxisArrowPosition\n  };\n}\n/**\n * Finds the client pixel coordinate of each edge for the element's bounding box,\n * and the bounding box's width & height\n *\n * @param {HTMLElement} element\n * @returns {{top: number, right: number, bottom: number, left: number, height: number, width: number}}\n */\n\n\nexport function getElementBoundingBox(element) {\n  var rect = element.getBoundingClientRect();\n  return {\n    top: rect.top,\n    right: rect.right,\n    bottom: rect.bottom,\n    left: rect.left,\n    height: rect.height,\n    width: rect.width\n  };\n}\n/**\n * Calculates the available content space between anchor and container\n *\n * @param {Object} anchorBoundingBox Client bounding box of the anchor element\n * @param {Object} containerBoundingBox Client bounding box of the container element\n * @param {number} buffer Minimum distance between the popover and the bounding container\n * @param {number} offset Distance between the popover and the anchor\n * @param {string} offsetSide Side the offset needs to be applied to, one\n *  of [\"top\", \"right\", \"bottom\", \"left\"]\n * @returns {{top: number, right: number, bottom: number, left: number}}\n */\n\nexport function getAvailableSpace(anchorBoundingBox, containerBoundingBox, buffer, offset, offsetSide) {\n  var _getBufferValues3 = getBufferValues(buffer),\n      _getBufferValues4 = _slicedToArray(_getBufferValues3, 4),\n      topBuffer = _getBufferValues4[0],\n      rightBuffer = _getBufferValues4[1],\n      bottomBuffer = _getBufferValues4[2],\n      leftBuffer = _getBufferValues4[3];\n\n  return {\n    top: anchorBoundingBox.top - containerBoundingBox.top - topBuffer - (offsetSide === 'top' ? offset : 0),\n    right: containerBoundingBox.right - anchorBoundingBox.right - rightBuffer - (offsetSide === 'right' ? offset : 0),\n    bottom: containerBoundingBox.bottom - anchorBoundingBox.bottom - bottomBuffer - (offsetSide === 'bottom' ? offset : 0),\n    left: anchorBoundingBox.left - containerBoundingBox.left - leftBuffer - (offsetSide === 'left' ? offset : 0)\n  };\n}\n/**\n * Computes the fit (overlap) of the content within the container, fit is in range 0.0 => 1.0\n * @param contentBoundingBox bounding box of content to calculate fit for\n * @param containerBoundingBox bounding box of container\n * @returns {number}\n */\n\nexport function getVisibleFit(contentBoundingBox, containerBoundingBox) {\n  var intersection = intersectBoundingBoxes(contentBoundingBox, containerBoundingBox);\n\n  if (intersection.left > intersection.right || intersection.top > intersection.top) {\n    // there is no intersection, the boxes are completely separated on at least one axis\n    return 0;\n  }\n\n  var intersectionArea = (intersection.right - intersection.left) * (intersection.bottom - intersection.top);\n  var contentArea = (contentBoundingBox.right - contentBoundingBox.left) * (contentBoundingBox.bottom - contentBoundingBox.top);\n  return intersectionArea / contentArea;\n}\n/**\n * Calculates the intersection space between two bounding boxes\n *\n * @param firstBox\n * @param secondBox\n * @returns {EuiClientRect}\n */\n\nexport function intersectBoundingBoxes(firstBox, secondBox) {\n  var top = Math.max(firstBox.top, secondBox.top);\n  var right = Math.min(firstBox.right, secondBox.right);\n  var bottom = Math.min(firstBox.bottom, secondBox.bottom);\n  var left = Math.max(firstBox.left, secondBox.left);\n  var height = Math.max(bottom - top, 0);\n  var width = Math.max(right - left, 0);\n  return {\n    top: top,\n    right: right,\n    bottom: bottom,\n    left: left,\n    height: height,\n    width: width\n  };\n}\n/**\n * Returns the top-most defined z-index in the element's ancestor hierarchy\n * relative to the `target` element; if no z-index is defined, returns 0\n * @param element {HTMLElement}\n * @param cousin {HTMLElement}\n * @returns {number}\n */\n\nexport function getElementZIndex(element, cousin) {\n  /**\n   * finding the z-index of `element` is not the full story\n   * its the CSS stacking context that is important\n   * take this DOM for example:\n   * body\n   *   section[z-index: 1000]\n   *     p[z-index: 500]\n   *       button\n   *   div\n   *\n   * what z-index does the `div` need to display next to `button`?\n   * the `div` and `section` are where the stacking context splits\n   * so `div` needs to copy `section`'s z-index in order to\n   * appear next to / over `button`\n   *\n   * calculate this by starting at `button` and finding its offsetParents\n   * then walk the parents from top -> down until the stacking context\n   * split is found, or if there is no split then a specific z-index is unimportant\n   */\n  // build the array of the element + its offset parents\n  var nodesToInspect = [];\n\n  while (true) {\n    nodesToInspect.push(element); // AFAICT this is a valid cast - the libdefs appear wrong\n\n    element = element.offsetParent; // stop if there is no parent\n\n    if (element == null) {\n      break;\n    } // stop if the parent contains the related element\n    // as this is the z-index ancestor\n\n\n    if (element.contains(cousin)) {\n      break;\n    }\n  } // reverse the nodes to walk from top -> element\n\n\n  nodesToInspect.reverse();\n\n  for (var _i2 = 0, _nodesToInspect = nodesToInspect; _i2 < _nodesToInspect.length; _i2++) {\n    var node = _nodesToInspect[_i2];\n    // get this node's z-index css value\n    var zIndex = window.document.defaultView.getComputedStyle(node).getPropertyValue('z-index'); // if the z-index is not a number (e.g. \"auto\") return null, else the value\n\n    var parsedZIndex = parseInt(zIndex, 10);\n\n    if (!isNaN(parsedZIndex)) {\n      return parsedZIndex;\n    }\n  }\n\n  return 0;\n}"]},"metadata":{},"sourceType":"module"}